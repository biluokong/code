#include <iostream>
#include <string.h>
using namespace std;

//接下来是c++提高部分，主要针对C++泛型编程和STL技术做详细讲解，探究C++的深层使用
//C++泛型编程主要利用的技术就是模板，C++提供两种模板机制：函数模板和类模板

class Person
{
public:
    int sex;
    int age;
    Person() { sex = 0, age = 0; }
};

template<typename T>
//void mysub()      //此处的函数想要使用，只能用显示指定类型的方式去使用
//{
//    cout << "dlja" << endl;
//}
T myAdd(T a, T b)
{
    return a + b;
}

template<typename T>
void test01(T a)
{
    cout << "模板函数" << endl;
}

template<typename T>
void test01(T a, T b)
{
    cout << "模板函数的重载函数" << endl;
}

//模板的重载，利用具体化Person的版本实现，具体化优先调用
void test01(Person a, Person b)
{
    cout << "具体化模板" << endl;
}

void test01(int a)
{
    cout << "普通函数" << endl;
}

//void main()
//{
    /* 1、模板的概念：模板就是建立通用的模具，能大大提高复用性
    * 
    *  2、函数模板
    *               （1）作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表
    *               （2）语法：template<typename T>      template――声明创建模板，其后面的符号是种数据类型，可以用class代替；T――通用的数据类型，名称可以替换，通常为大写字母
    *                                  函数声明或定义
    *               （3）使用模板方式：①自动类型推导       ②显示指定类型
    *               （4）目的：提高复用性，将类型参数化
    *               （5）注意事项：①自动类型推导，必须推导出一致的数据类型T，才可以使用     ②模板必须要确定出T的数据类型，才可以使用
    *               （6）普通函数与函数模板的区别：普通函数调用时会发生自动类型转换，函数模板调用时只有使用显示指定类型的方式，才可以发生自动类型转换（建议用显示指定类型的方式）
    *               （7）普通函数与函数模板的调用规则(因为普通函数和模板函数也可以发生函数重载)：  
                                                                                                                                                     ①如果函数模板和普通函数都可以实现时，优先调用普通函数         
                                                                                                                                                     ②函数模板也可以发生函数重载
                                                                                                                                                     ③可以通过空模板参数列表来强制调用函数模板   语法：模板函数名<>(实参列表);(即加个空的尖括号）
                                                                                                                                                     ④如果函数模板可以产生更好的匹配，优先调用函数模板                                                                                                                                                   如：普通函数需要自动类型转换，而函数模板不用的话，编译器会优先调用函数模板
                                                                                                                                                     补：建议不要写实现一样的普通函数和函数模板，实际开发中如此意义不大
                    （8）局限性：不够万能。
                           如果函数体内是赋值赋值操作(如a=b)时，当传入数组时就无法实现看；
                           如果传入数据是自定义是数据类型，也无法实现，需要用模板的重载，为特定的类型提供具体化的模板，它是普通函数，优先调用的（有一些涉及到运算符的实现也可以用运算符重载实现）
    */
    /*int b = 3.12;*/
    /*int a = myAdd(12, 3.3);*/       //此处报错，因为函数模板调用时，不会发生隐式类型转换(自动类型转换)
   /* int a = myAdd<int>(12, 3.3);*/    //此处没有问题，是因为使用了显示指定类型的方法

    /*cout << a<<" " << b << endl;*/
    //cout <<myAdd(3, 4) << endl;
    //cout <<myAdd<int>(3, 4) << endl;        //此处的<int>是指定显示或返回值类型
    //cout <<myAdd<int>(3.0, 4.12) << endl;
    //cout <<myAdd(3.0, 4.12) << endl;
    //cout <<myAdd<double>(3.0, 4.12) << endl;

    /*mysub();  */      //编译器报错，模板必须要确定出T的数据类型，才可以使用；可以用显示指定类型的方式去使用
    /*mysub<int>();*/

    //test01(3);      //优先调用普通函数
    //test01<>(3);        //可以用空模板参数列表来强制调用模板函数
    //test01(3, 6);       //调用模板函数的重载函数
    //test01('a');        //此处用普通函数会发生自动类型转换，而用模板函数则直接当字符型，不用多进行自动类型转换，所以此处编译器优先使用模板函数
    //Person a;
    //Person b;
    //test01(a, b);     //模板重载，具体化Person的版本优先调用
    //test01(new Person, new Person);     //则种方法仍调用模板函数，因为编译器要检测是何种类型的指针，然后确定类型，相当于要进行自动类型转换，使用优先使用模板函数
//system("pause");
//}