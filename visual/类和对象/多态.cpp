#include<iostream>
#include<string>
using namespace std;

class MyAnimal
{
public:
    /* virtual*/ void speak()
    {
        cout << "动物在说话" << endl;
    }
};

class Cat : public MyAnimal
{
public:
    void speak()
    {
        cout << "猫在喵喵叫" << endl;
    }
};

void test21(MyAnimal& a)
{
    a.speak();
}

//void main()
//{
    /* 1、基本概念
    * 
    *               （1）分类：      ①静态多态：函数重载和运算符重载，复用了函数名         ②动态多态：派生类和虚函数实现运行时
    * 
    *               （2）静态多态与动态多态的区别：        ①静态多态的函数地址早绑定 - 编译阶段确定函数地址          ②动态多态的函数地址晚绑定 - 运行阶段确定函数地址
    * 
    *               （3）动态多态的满足条件：       ①有继承关系          ②子类重写父类的虚函数（子类的重写函数virtual可加可不加，因为父类的函数加后，其子类派生函数会自动加）
    * 
    *               （4）多态多态的使用：父类的指针或引用  指向子类对象
    * 
    *               （5）实现动态多态的方法：使父类的同名方法变为虚函数（加virtual），以使父类的指针或引用实现地址动态绑定，不这么做，则会使用静态绑定
    * 
    *                 补充：①重写：子类的函数其返回值类型、函数名、参数列表都与父类的函数完全一致，只有函数体部分不同
    *                           ②这里的Animal没加virtual时内存占一个字节，加之后变为了4个字节，多了一个虚函数(表)指针
    *                           ③虚函数(表)指针(vfbtr) 指向 虚函数表(vftable)，表内记录虚函数的地址。比如这里的Animal，表内含有&Animal::speak()，子类同样含有&Animal::speak()。
    *                           ④当子类重写父类的虚函数时，子类的虚函数表内的内容会换成子类的同名(虚)函数地址（可用开发人员命令符验证）
    *                           ⑤最终当父类的指针或引用指向子类对象时，发生多态，调用子类的虚函数表中的函数
    */
    /*Cat c;
    test21(c);*/      //这里我需要的是猫喵喵叫，但是却输出了动物在说话，这是因为这里进行的是早绑定，地址早确定好了，解决方法：让动物类中的重名函数加关键字virtual变此虚函数

    /* 2、多态的优点：         ①代码组织结构清晰           ②可读性强               ③利于前期后后期的扩展和维护
    * 
    *               （1）开闭原则：在开发中，提倡开闭原则，即对扩展开放，对修改关闭
    * 
    *               （2）例子：定义一个抽象的计算器类，只有两个int属性和一个函数virtual getResult( ) {return 0;}，然后需要扩展时，定义子类加法、减法……计算器
    *                                  去继承父类重写此虚函数，用时创建一个抽象的计算器类指针指向堆区开辟的扩展的子类对象，然后调用getResult函数就行了。这样就不用修改源码了
    */
    /* 3、纯虚函数和抽象类
    * 
    *               （1）纯虚函数：    ①意义：在多态中，通常父类虚函数的实现是毫无意义的，主要是调用子类重写的内容，则此时可将虚函数改写为纯虚函数
    *                                             ②语法：virtual 返回值类型 函数名 （参数列表）= 0；
    *                                             ③抽象类：有纯虚函数的类称为抽象类
    * 
    *               （2）抽象类特点：       ①无法实例化对象            ②子类必须重写抽象类中的纯虚函数，否则它也会变为抽象类                                      
    */
    /* 4、虚析构和纯虚析构
    * 
    *                   （1）引入：多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构函数
    * 
    *                   （2）意义：可以解决上述问题
    * 
    *                   （3）解决方式：将父类中的析构函数改为虚析构或者纯虚析构
    * 
    *                   （4）虚析构和纯虚析构共性：      ①可以解决父类指针释放子类对象         ②都需要有具体的函数实现（因为可能用到父类的析构函数来释放父类创建的成员属性）
    *                                                       区别：      如果是纯虚析构，则该类属于抽象类，无法实例化对象
    */
    /*system("pause");
}*/