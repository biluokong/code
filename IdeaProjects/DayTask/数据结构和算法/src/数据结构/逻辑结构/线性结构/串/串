
1、串的定义：s = "a1a2a3……an"（n>=0）
        说明：s是串名；a1a2……an是串值；n是串长

2、几个术语：
        （1）空串：n = 0 的串
        （2）子串；一个串中任意个连续字符组成的子序列（含空串）称为该串的子串
        （3）真子串：指不包含自身的所有子串
        （4）字符位置：字符在序列中的序号
        （5）子串位置：子串第一个字符在主串中的位置
        （6）空格串：由一个或多个空格组成的串，与空串不同
        （7）串相等：长度相等且对应每个字符都相等

3、串的链式储存结构
        （1）优点：操作方便
        （2）缺点：储存密度较低
        （3）解决缺点的方法：可将多个字符存放在一个结点中，用块链结构

4、串的模式匹配算法
        （1）目的：确定主串中所含子串(模式串)第一次出现的位置（定位）
        （2）算法种类：    ①BF算法（Brute-Force，又称古典的、经典的、朴素的、穷举的；有叫简单匹配算法，采取穷举法）
                   ：    ②KMP算法：（特点：速度快）

                                                  { max{ k|j<k<i, 且“P1...P(k-1)”（从头开始的 k-1 个元素） = “P(i-k+1)...P(i-1)”（i前面的 k-1 个元素） }                  { max{ k|j<k<i, 且“P1...Pk”（从头开始的 k 个元素） = “P(i-k)...P(i-1)”（i前面的 k 个元素）
5、KMP算法（重点）：next[i](数据存储下标从1开始的情况) = { 0， i = 0或1                                                                                         （从0开始）= { -1， i = 0;
                                                  { 1， 其它情况                                                                                                     {  0， 其它情况

6、next数组的改进：
        （1）缺点：对于“aaaab”种模式串，会重复比较，使不该比较的次数增加了；

        （2）解决方法：nextval(nextValue)[i]（数据存储下标从1开始的情况） = { 0,  i = 0或1                                               （从0开始） = { -1， i = 0
                                                                    { pi == p(next[i]) ? nextval[next[i]] : next[i]， i > 1                  { pi == p(next[i]) ? nextval[next[i]] : next[i]， i > 0

7、匹配的算法的时间复杂度
        （1）BF算法：总比较次数为：（n-m)*m+m = (n-m+1)*m；若m<<n，则算法时间复杂度为O(n*m)
        （2）KMP算法：时间复杂度：O(n+m)