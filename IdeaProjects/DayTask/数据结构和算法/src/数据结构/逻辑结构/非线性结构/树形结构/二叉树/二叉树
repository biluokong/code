
1、性质
        （1）在二叉树的第 i 层上至多有 2^(i-1) 个结点(i>=1)，至少有1个结点
        （2）深度为 k 的二叉树至多有 2^k - 1 个结点（k>=1），至少有 k 个结点
        （3）对任何一棵二叉树 T，如果其叶子树为 n0，度为2的结点数为 n2，则 n0 = n2 + 1
             证明如下：从下往上看：总边数B = n(总结点数) - 1(根结点没有双亲)
                     从上往下看：总边数B = n2(深度为2的结点数)*2 + n1(深度为1的结点数)*1
                     总结点数n = n2 + n1 + n0
                     联立以上三式，解得n0 = n2 + 1

2、两种特殊形式的二叉树
        （1）满二叉树：一棵深度为 k 且有 2^k - 1（最多）个结点的二叉树
               特点：①每一层上的结点数都是最多大结点数（即每层都满）  ②叶子结点都在最底层
               编号规则：①从根结点开始，自上而下，自左而右   ②每一个结点位置都有元素

        （2）完全二叉树：深度为 k ，具有 n 个结点，并且其每一个结点都与深度为 k 的满二叉树中编号为 1~n 的结点一一对应(编号、次序和层数)
                      注：即在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树（一定是连续的！）
               特点：①叶子只可能分布在层次最大的两层上     ②对任意结点，如果其右子树的最大层次为 i，则其左子树的最大层次必为 i 或 i+1
               性质1：具有 n 个结点的完全二叉树的深度为[log₂n]+1。  [log₂n]表示不大于 log₂n 的最大整数
               性质2：如果对一棵树有 n 个结点的完全二叉树（深度为 [log₂n]+1 ）的结点按层序编号（从第1层到 [log₂n]+1 层，每层从左到右），则对任一结点i(1<=i<=n),有：
                     ①如果 i=1，则结点i是二叉树的根，无双亲；如果i>1，则其双亲是结点[i/2]
                     ②如果 2i>n，则结点i为叶子结点，无左孩子；否则，其左孩子是结点2i
                     ③如果 2i+1>n，则结点i无右孩子；否则，其右孩子是结点2i+1

3、储存结构
        （1）顺序储存
                实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素
                特点：结点间关系蕴含在其储存位置中；当出现空结点时，会浪费储存空间；适用于存满二叉树和完全二叉树
                     最坏情况：深度为k的且只有k个结点的单支树需要长度为2^k-1的一维数组

        （2）链式储存结构
                储存方式：结点结构为：lchild data rchild；lchild和rchild指向左右孩子
                特点：在有n个结点的二叉链表中，有n+1个链域
                证明：总共有2n个指针域，从下往上看，会有n-1个结点的链域存放指针(因为每一个结点都有一个双亲，除了根结点)，指向非空孩子结点，相见即得上述结论

        （3）补充：三叉链表：结点结构：lchild data parent rchild。  （即多了一个指向双亲的指针域）

4、二叉树的遍历
        （1）定义：顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次(又称周游)
                 访问：其含义很广，可以是对结点的各种处理，如输出结点的信息、修改结点的数据等，但要求这种访问不会破坏原来的数据结构
        （2）目的：得到树中所有结点的一个线性排列
        （3）用途：它是树结构中插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心
        （4）遍历方法：L表示遍历左子树；D表示访问根结点；R表示遍历右子树。则遍历整个二叉树的方案6种：DLR、LDR、LRD、DRL、RDL、RLD
                    若规定先左右右，则只有3种情况：①DLR——先(根)序遍历   ②LDR——中(根)序遍历   ③LRD——后(根)序遍历
        （5）根据遍历次序确定二叉树：①若二叉树各结点的值均不相同，则二叉树的先序序列、中序序列和后序序列都是唯一的
                                ②由二叉树的先序序列和中序序列、后序序列和中序序列可以确定唯一一棵二叉树，知道先序序列和后序序列是没法确定一棵二叉树的（先或后确定根，中确定左右子树）

5、遍历二叉树的递归算法
        （1）分析：从递归角度，3种遍历算法是完全相同的，或者说着3种算法的访问路径是相同的，只是访问结点的时机不同
        （2）复杂度：①时间复杂度：O(n)  (每个结点只访问一次)     ②空间复杂度：O(n)  (栈占用的最大辅助空间)

6、遍历二叉树的非递归算法（用栈实现）
        （1）中序遍历
                基本思想：建立一个栈；根结点进栈，遍历左子树；根结点出栈，输出根结点，遍历右子树

7、二叉树的层次遍历（用队列实现）
        （1）算法思路
                使用一个队列将根结点进队；
                队不空时循环：从队列中出列一个结点，访问它：  ①若它有左孩子结点，将左孩子结点进队      ②若它有右孩子结点，将右孩子结点进队

8、线索二叉树
        （1）问题：任何寻找特定遍历序列中二叉树结点的前驱和后继
        （2）解决方法： ①通过变量寻找———费时间   ②再增设前驱、后继指针域——增加了储存负担  ③利用二叉树链表中的空指针域
        （3）利用空指针域的方法：若结点的左孩子为空，则将其指针域指向其前驱；若右孩子为空，则将其指针域指向其后继——则种改变指向的指针称为“线索”
        （4）定义：加上了线索的二叉树就叫做线索二叉树
        （5）区分是指向孩子还是指向前驱或后继的方法：每个结点增设两个标志域lTag和rTag,并约定：lTag=0或rTag=0，指向左孩子或右孩子；lTag=1或rTag=1，指向前驱或后继
        （6）结点结构：lChild lTag data rTag rChild
        （7）没有前驱和后继的结点其空指针域处理方法：增设一个头结点：lTag=0，lChild指向根结点；rTag=1，rChild指向遍历序列中的最后一个结点
                                             而遍历序列中的第一个结点的lc域和最后一个结点rc域都指向头结点（这样处理更方便）