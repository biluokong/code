哈夫曼树(最二叉优树)

1、基本概念
        （1）判断树：用于描述分类过程的二叉树
        （2）路径：从树中的一个结点到另一个结点之间的分支构成这两个结点间的路径
        （3）结点的路径长度：两结点将路径的分支数
        （4）数的路径长度：从树根到每一个结点的路径长度之和。记作：TL
                在结点数目相同的二叉树中，完全二叉树的路径长度最短（完全二叉树的路径长度最短，但路径长度最短的数不一定是完全二叉树，这是个充分条件）
        （5）权(weight)：将数中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权
        （6）结点的带权路径长度：从根结点到该结点之间的路径长度与该结点的权的乘积
        （7）树的带权路径长度：树中所有叶子结点的带权路径长度之和，记作：WPL=∑w(k)l(k)（k=1、k=2……k=n）  w:权值  l:结点到根的路径长度
        （8）哈夫曼树：最优树，带权路径长度(WPL)最短的树
                注：
                   ①“带权路径长度最短”是在“度(子树最大数)相同”的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等
                   ②满二叉树不一定是哈夫曼树
                   ③哈夫曼树中权越大的叶子离根越近
                   ③具有相同带权结点的哈夫曼树不唯一

2、构造算法
        （1）贪心算法：构造哈夫曼树时首先选择权值小的叶子结点（因为哈夫曼树中权越大的叶子离根越近）
        （2）构造树的思路
                ①根据n个给定的权值 {w1,w2,w3,……,wn} 构成n棵二叉树的森林 F={T1,T2,……,Tn}，其中Ti只有一个带权为wi的根结点
                ②在F中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和
                ③在F中删除这两棵树，同时将新得到的二叉树加入森林中
                ④重复②和③，直到森林中只有一棵树为止，这棵树即为哈夫曼树
                    口诀：构造森林全是根，选用两小造新树；删除两小添新人，重复2、3剩单根
                注：
                    ①哈夫曼树的结点的度数为0或2，没有度为1的结点
                    ②包含n个叶子结点的哈夫曼树中共有 2n-1 个结点
                    ③包含n颗树的森林要经过 n-1 次合并才能形成哈夫曼树，共产生 n-1 个新结点，且这 n-1 个新结点都是具有两个孩子的分支结点，由③可推出②
        （3）算法的实现：采用顺序储存结构——一维数组  结点成员：weight parent lCh rCh
                    ①初始化 HT[1……2n-1]：lCh=rCh=parent=0
                    ②输入初始n个叶子结点的权：置 HT[1……n] 的weight值
                    ③进行以下 n-1 次合并，依次产生 n-1 个结点 HT[i]，i=i+1……2n-1
                        a.在 HT[1……i-1] 中选两个为被选过(从parent==0的结点中选)的weight最小的两个结点 HT[s1] 和 HT[s2]，s1和s2为两个最下结点的下标
                       b.修改 HT[s1] 和 HT[s2] 的parent值：HT[s1].parent=i; HT[s2].parent=i;

3、哈夫曼编码
        （1）问题1：若采用长度相等的编码，则会浪费储存空间；若采用长度不等的编码，则可能会重码，无法正确翻译
                解决的思路：采用第二种编码形式，但必须使任一字符的编码都不是另一个字符的前缀
        （2）前缀编码：任一字符的编码不是另一个字符的编码的前缀的编码叫做前缀编码
        （3）问题2：什么样的前缀码能使电文总长度最短——哈夫曼编码
        （4）方法
                ①统计字符集中每个字符在电文中出现的平均概率(概率越大，要求编码越短)
                ②利用哈夫曼树的特点：权越大的叶子离根越近
                    将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短
                ③在哈夫曼树的每个分支上标上0或1：结点的左分支标0，右分支标1
                    把从根到每个叶子结点的路径上的标号连接起来，作为该叶子代表的字符的编码
        （5）问题3：为什么哈夫曼编码能够保证是前缀编码？
                因为没有一片树叶是另一片树叶的的祖先，所以每个结点的编码就不可能是其它叶子结点编码的前缀
        （6）问题4：为什么哈夫曼编码能够保证字符编码总长度最短？
                因为哈夫曼树的带权路径长度最短，故字符编码的总长度最短
        （7）性质:
                ①哈夫曼编码是前缀码
                ②哈夫曼编码是最优前缀码
        （8）代码实现：通过结构数组 结点：weight patent lCh rCh
                如何得到相应的0或1：从叶子结点往上的更好实现